use crate::{
    ast::*,
    types::{ProtoType, Literal, BinOpcode, UnOpcode}
};
grammar;

pub Program: Vec<Binding> = {
    Statement*,
};

Statement: Binding = {
    TypeDecl,
    Binding,
    FnBinding,
}

Comma<T> : Vec<T> = {
    <T> => vec![<>],
    <v: (<T> ",")+> <last: T?> => {
        let mut v = v;
        if let Some(e) = last {
            v.push(e);
        }
        v
    }
}

// at least 2 elements
Comma2<T>: Vec<T> = {
    <v: (<T> ",")+> <last: T> ","? => {
        let mut v = v;
        v.push(last);
        v
    }
}

TypeDecl: Binding = {
    "type" <name:ID> <vars:TypeVars> "=" <variants:SumVarDecl+> ";" => Binding::Type {<>},
};

TypeVars: Vec<String> = {
    "()" => vec![],
    ID => vec![<>],
    "(" <Comma<ID>> ")",
}

SumVarDecl: (String, ProtoType) = {
    "|" <ID> <Type>,
};

Binding: Binding = {
    <Pattern> "=" <Expr> ";" => Binding::Value(<>, false),
};

FnBinding: Binding = {
    "fn" <name:ID> "=" "{" <v:Comma<Arm>> "}" => Binding::Value(Pattern::Bind(name), Expr::Closure(v), false),
    "rec" "fn" <name:ID> "=" "{" <v:Comma<Arm>> "}" => Binding::Value(Pattern::Bind(name), Expr::Closure(v), true),
};

Arm = {
    <Pattern+> "=>" <Expr>,
};

Pattern: Pattern = {
    Literal => Pattern::Literal(<>),
    "_" => Pattern::Wild,
    ID => Pattern::Bind(<>),
    "(" <v:Comma2<PatternH>> ")" => Pattern::Tuple(v),
    "(" <PatternH> ")",
};

PatternH: Pattern = {
    <id:ID> <field:Pattern> =>  Pattern::SumVar(id, Box::new(field)),
    Pattern,
};

Class<Op,NextClass>: Expr = {
    <l:Class<Op,NextClass>> <op:Op> <r:NextClass> => 
        Expr::BinOp(Box::new(l), op, Box::new(r)),
    NextClass,
};

UnaryClass<Op, NextClass>: Expr = {
    <op:Op> <e:UnaryClass<Op,NextClass>> => Expr::UnOp(op, Box::new(e)),
    NextClass,
};

Type: ProtoType = {
    <SimpleType>,
    <from:SimpleType> "->" <to:Type> => ProtoType::Function(Box::new(from), Box::new(to)),
};

SimpleType: ProtoType = {
    "()" => ProtoType::Unit,
    "int" => ProtoType::Int,
    "bool" => ProtoType::Bool,
    "string" => ProtoType::String,
    "(" <Type> ")",
    <ID> => ProtoType::Generic(<>),
    <name:ID> <tp:SimpleType> => ProtoType::Sum(name, Box::new(tp)),
    "(" <Comma2<Type>> ")" => ProtoType::Tuple(<>),
};

pub Expr = Class<Op0,Expr1>;       // and or
Expr1 = Class<Op1,Expr2>;       // compare
Expr2 = Class<Op2,Expr3>;       // eq !=
Expr3 = Class<Op3,Expr4>;       // factor
Expr4 = Class<Op4,Expr5>;       // term
Expr5 = UnaryClass<Op5,Term>;   //unary

Term: Expr  = {
    <hd:Base> <v:Base*> => {
        let mut expr = hd;
        for e in v {
            expr = Expr::Application(Box::new(expr), Box::new(e));
        }
        expr
    },
};

Base: Expr = {
    "if" <cond:Expr> "then" <a:Expr> "else" <b:Expr> "end" => {
        Expr::Conditional(Box::new(cond), Box::new(a), Box::new(b))
    },
    "fn" "{" <v:Comma<Arm>> "}" => Expr::Closure(v),
    <Literal> => Expr::Literal(<>),
    <bound:ID> => Expr::Bound(bound),
    "(" <Comma2<Expr>> ")" => Expr::Tuple(<>),
    "(" <Expr> ")",
};

Literal: Literal = {
    r#""(\\.|[^"\\])*""# => Literal::String(<>[1..(<>.len()-1)].to_string()),
    r"-?[0-9]+" => Literal::Int(isize::from_str_radix(<>, 10).unwrap()),
    "true" => Literal::Bool(true),
    "false" => Literal::Bool(false),
    "()" => Literal::Unit,
};

Op0: BinOpcode = {
    "and" => BinOpcode::And,
    "or" => BinOpcode::Or,
};

Op1: BinOpcode = {
    ">" => BinOpcode::Greater,
    "<" => BinOpcode::Less,
    ">=" => BinOpcode::GreaterEq,
    "<=" => BinOpcode::LessEq,
};

Op2: BinOpcode = {
    "=" => BinOpcode::Equal,
    "!=" => BinOpcode::NotEq,
};

Op3: BinOpcode = {
    "+" => BinOpcode::Add,
    "-" => BinOpcode::Sub,
};

Op4: BinOpcode = {
    "*" => BinOpcode::Mul,
    "/" => BinOpcode::Div,
    "%" => BinOpcode::Mod,
};

Op5: UnOpcode = {
    "not" => UnOpcode::Not,
    "-" => UnOpcode::Minus,
};

ID: String = {
    r"[a-zA-Z_'][a-zA-Z_'0-9]*" => <>.to_string(),
}