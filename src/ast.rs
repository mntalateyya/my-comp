//! The AST generated by the parser.

use types::{ProtoType, Literal, BinOpcode, UnOpcode};

/// Binds a name to a type definition or a expression to a pattern,
/// every top level declaration is of this type
#[derive(Debug)]
pub enum Binding {
    Type {
        /// name to bind the type to
        name: String, 
        /// generic variables
        vars: Vec<String>,
        /// variants' names and arguments' types
        variants: Vec<(String, ProtoType)> },
    Value(Pattern, Expr),
    Function {
        name: String,
        variants: Vec<(Vec<Pattern>, Expr)>,
    }
}

/// A pattern or LHS of a binding to match
#[derive(Debug)]
pub enum Pattern {
    /// Wild card matches everything
    Wild,
    /// matches a concrete value, e.g. a number or a string
    Literal(Literal),
    /// Binds any matched expression to a name
    Bind(String),
    /// matches a tuple (recursively)
    Tuple(Vec<Pattern>),
    /// matches a variant of a sum type and its argument with leading path
    SumVar(String, Box<Pattern>),
}

/// An expression or RHS that evaluates to a value,
#[derive(Debug)]
pub enum Expr {
    /// a value literal e.g int, string
    Literal(Literal),
    /// value of a name that was previously bound with leading path
    Bound(String),
    /// a tuple of values
    Tuple(Vec<Expr>),

    /// the value of applying a binary operation on two Exprs
    BinOp(Box<Expr>, BinOpcode, Box<Expr>),
    /// the value of applying a unary operation on an Expr
    UnOp(UnOpcode, Box<Expr>),

    /// A function is a sequence of patterns and corresponsing expressions
    Function(Vec<(Vec<Pattern>, Expr)>),
    /// Apply an expression on an expression
    Application(Box<Expr>, Box<Expr>),
    /// if e1 then e2 else e3
    Conditional(Box<Expr>, Box<Expr>, Box<Expr>),
}